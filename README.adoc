
:toc:
:toc-placement!:

This algorithm competition allows programmers and math puzzle enthusiasts to
compete by writing an algorithm to solve a math puzzle using as little
"computational cost" as possible.

A python utility is supplied which allows one to write their algorithm in
python and easily check its correctness as well as have its computational cost
calculated with some chosen inputs.

toc::[]

= Contest details

This contest is related to previous challenges from Chia Networks, but this
contest is not run by nor affiliated with them. It is merely being setup by a
fan of the math puzzle embedded in those contests.

== Rules

The following are suggested rules, and will be finalized after it has time
to get some feedback from the community.

. Anyone may enter (explicitly including Chia employees), and winner(s) will be awarded prizes pledged by community donors.
. Contest period for entries ends on August 31th, 2020 at 00:00 UTC.
. Participants must:
.. Provide a publicly accessible git repo, which must contain:
... a python file: `entry.py` -- contains code of your algorithm which is compatible with testing by `run_trial.py`
... explanation of the algorithm should be supplied (either as comments in the code, or a separate document included in the git repo)
... a text file: `prize.txt` -- cryptocoin address(es) where prizes should be sent
.. Register an entry before the contest period ends by submitting a pull
request to this github repo which adds the following information
to `entry_registration.txt`:
... the git hash of the commit of your git repo to be considered for the contest entry
... publicly accessible url from which the git repository can be cloned after the contest period ends
.. [Optional] a contest entry can be registered without releasing your algorithm details until the contest period ends.
... Register as normal, but keep your git repo private, or just not pushed to the public server, until the contest period ends
... In this case, the repo should be made public within a day of the contest period ending.
. Tied scores will be resolved by whoever submitted first.
. An entry should out perform the provided example entries to be eligible for a prize.
. To resolve disputes, the person pledging a prize has final say on that prize.
What follows are suggestions for handling some situations:
.. Entries which are found to evade or directly manipulate the computation cost tracking will be invalidated.
.. If there are prizes for 2nd place or below, then duplicate entries or entries deemed as "substantially duplicate" of other entries will be invalidated except for the one submitted first.
. Participants may discuss, share, and collaborate on ideas however they choose.
. Contest test values will be generated by running
+
  $ ./create_test_file.py -s "$SECRET_SEED" -n 100 -b 2048 contest.txt
+
. Contest test seed `$SECRET_SEED` is precommitted by
+
  $ echo "$SECRET_SEED" | sha256sum
  efa47bb2d9c31d41c921c9102a1dc2d13a007e180bdce336152de8769b98e31b  -
+
. Contest entries will be scored by running (lowest total cost wins)

  $ ./run_trial.py -t contest.txt entry


== Current prize pledges

* user "PulledPork" pledges 2 ETH for first place, and I will not enter the contest for added fairness


== The main puzzle

This problem can be approached with basic algebra skills supplemented with
knowledge of how to solve linear equations involving integers.

What follows is an algebra description of the problem, which skips the deeper
math. For those wanting to explore the details themselves, there is a reference section at the end with links to some helpful material.

Consider a cube with integers on each corner,
and the values labelled a,b,c,d,e,f,g,h.
....
       e ---- f
      /|     /|
     / |    / |
    a ---- b  |
    |  g --|- h
    | /    | /
    |/     |/
    c ---- d
....

Associated with these 8 cube values are three tuples of values
(A1,B1,C1), (A2,B2,C2), (A3,B3,C3), given by what will be referred to as the
"cube equations":
....
    A1 = bc - ad
    B1 = -ah + bg + cf - de
    C1 = fg - eh

    A2 = ce - ag
    B2 = -ah - bg + cf + de
    C2 = df - bh

    A3 = be - af
    B3 = -ah + bg - cf + de
    C3 = dg - ch
....

Given any cube values a,b,c,d,e,f,g,h, it is clear that the tuple values
A1,A2,etc. are uniquely determined.

What is not obvious from this, is that given any tuple values (A1,B1,C1),
(A2,B2,C2), (A3,B3,C3), if there is a solution, the cube values
a,b,c,d,e,f,g,h are uniquely deteremined up to an overall sign.
(A sketch of a proof is provided in '<<useful-algebra-results>>'.)

So up to an overall sign, a cube can be uniquely referred to by either the
eight corner values or the three tuples.

=== Algorithm to create

In the competition, the goal is to write a function which will take as
input (a,b,c,d,e,f,g,h) specifying a cube, with the following additional
guarantees that may make the algebra easier:

* the first two tuples are equal (A1,B1,C1) = (A2,B2,C2)
* `B1^2 - 4 A1 C1 = B2^2 - 4 A2 C2 = B3^2 - 4 A3 C3 = -p`,
where p is a prime and p = 7 (mod 8).

The function must then calculate and return new cube values
(a',b',c',d',e',f',g',h') such that
```
   (A1',B1',C1') = (A2',B2',C2') ~ (A3,B3,C3)
```
with as little computational cost as possible. (As discussed in the
'<<skim-some-deeper-math-details>>' section, the `~` in the above equation is
referring to an equivalence relation that gives more freedom in the solution
if desired. Pursing that is not strictly required, and replacing the `~` with
a normal `=` in that equation would still give acceptible solutions.)

This function will be tested by giving it an initial cube and then repeated
application of the function on its own output. So it is also advantageous to
keep the size of the integers in your cube solution from getting larger each
application.

== Contents of this repo

....
create_test_file.py -- Used to create new test sets with pre-computed answers.
                       Run without arguments to see the options.

run_trial.py -- Used to test an algorithm entry.
                Run without arguments to see the options.

example.py -- example algorithm, which just supplies a run function
example2.py -- example algorithm, which also supplies a custom setup function
               for caching some calculated values for reuse

test16.txt -- a small test file with bitsize=16,
              useful for quickly verifying an algorithm is working

test128.txt -- a longer test files with bitsize=128
test2048.txt -- a test file with bitsize=2048
....


== Details of entry code and use of contest library

=== algocomp

The algocomp library defines a class TrackedNumber which for the most part
can be treated like an integer. This handles cost tracking of operations
behind the scenes. Ideally, the user never needs to deal with this directly or
even be aware which variables are actually integers vs. TrackedNumbers.

Supported operations::
* unary `+`, `-`, `abs()`
* bool tests: `bool()`, `==`, `>=`, `>`, `+<=+`, `<`, `!=`
* basic arithmetic: `+`, `-`, `*`, `%`, `divmod`, `//` (integer floor division)
* power: `+**+` (however, as this needs to do extra checks, it is recommended things like `+x**2+` are just written explicitly as `x*x`)

A list of "Do Nots"::
* Do not use assignment operators. Instead of writing "a += b" explicitly
write it out as "a = a + b". This is necessary to allow promotion of ints
to tracked values for cost tracking. It also prevents aliasing issues.
* Do not use `/` for division. Instead use `//`, or if you want to denote the
division should be exact, use `exact_div`. The `/` division creates floats
from integers even if the division is exact.
* Do not use bit manipulations. Instead strive to do as much possible with
the basic arithmetic operations and the provided library routines. Bit
manipulations operators were not defined for the tracked values to strongly
encourage this.
* Do not try to cast an expression or value using int(). This implies you
expect an intermediate value in some calculation to be a float, which when
working with large ints means a lot of precision was just lost. So this is
an indicator of something going wrong. Furthermore, allowing this would also
strip any cost tracking from a value, so this was explicitly not included
as a supported operation, to prevent anyone from accidentally doing this.
* Do not try to extract the internal int value from a tracked object, or
directly manipulate the int value inside a tracked object. This would
evade cost tracking.
** one exception is when you want to do a sanity check assert with a small
calculation. You can import
+
  from algocomp.tracked_number.coerce_int as coerce_int
+
and then use coerce_int to strip values down to an int to avoid the cost
tracking in an assert.


Integer math routines supplied by algocomp::
* `isqrt(x)` -- integer square root, returns sqrt(x) rounded down to nearest integer
* `exact_div(a,b)` -- division, but raises exception if b does not divide a
* `divmod_min(a,b)` -- returns q,r such that `a = q*b + r`, with minimum `|r|`
* `mod_min(a,b)` -- returns r such that `r = a (mod b)`, with minimum `|r|`
* `gcd(a,b)` -- returns the greatest common divisor of a and b
* `xgcd(a,b)` -- returns (g,x,y) such that `a*x + b*y = g = gcd(a,b)`
* `mod_inverse(x,M)` -- returns a such that `a*x = 1 (mod M)`.
* `partial_xgcd(a,b,L)` -- returns (u,x,v,y) such that
.. `u*x - v*y = a`,   with `+|v| <= L+` or `u = 0`
.. there exists a matrix M such that `+[u v] = [a b] M+`, with `det(M) = 1`
.. `gcd(u,v) = gcd(a,b)`
.. `gcd(x,y) = 1`
* `solve_linear(a,b,c)` -- returns (x,y) such that `a*x + b*y = c`, with `|x|` minimized
* `solve_linear_x(a,b,c)` -- like `solve_linear` but only calculates the `x` value

Useful routines for dealing with binary quadratic forms::
* `reduce_form(a,b,c)` -- returns the reduced form equivalent to (a,b,c)
* `nudupl(a,b,c,L=None)` -- returns a reduced form (A,B,C) that
is the squared composite form of (a,b,c), the parameter L is a
tuning parameter for partial reduction based on the discriminant
(if not supplied, it is calculated from a,b,c).

Useful routines for dealing with a cube as a tuple of 8 values::
* `transform_cube(cube, r,s,t,u)` -- applies a matrix transformation to a cube,
which preserves (A1,B1,C1) and (A2,B2,C2), but does an equivalence
transformation on (A3,B3,C3)
* `print_cube_stats(cube)` -- debug print details about cube values and forms

=== Cost calculations

The actual cost values have no explicit meaning.

Costs were assigned to the basic arithmetic operations, and then the cost of all other routines are determined based on use of these operations.

The intention was to make the cost of `div > mul > add,sub` in such a way that there are no silly/hacky incentives to unroll muls as adds, or divs as subtracts, etc.
The ultimate goal is to have the costs reasonable enough that people write the algorithms naturally, and then for them to be ranked mostly by (div, mul, add+sub).

Constants in the code are still just ordinary ints, and are promoted to cost tracked numbers when an operation involves them with a cost tracked variable.
This is a necessity due to how it was decided to handle cost tracking. Furthermore, most constants in the algorithms will just be small, such as 0, 1, 2, or 4.
And the costs only remain untracked while they operate with other ints.

Some details

* arithmetic operations cost more with larger operands
* all unary operations such as negation `-` or `abs()` or `bool()` are free (as the usual way of storing large integers makes manipulating the sign, or checking if non-zero, really cheap)
* boolean compares are free (unless something is causing large values to have almost identical values, compares of large integers should still be fast)
* with the same operands `+`, and `-` have the same cost
* with the same operands `//`, `%`, and `divmod` are all considered a single divisioin and all have the same cost. So if you need both the quotient and remainder, use divmod, that is what it is there for.


=== Algorithm contest entry

An algorithm entry may optionally define:

* a function `setup(discriminant)`
** parameter discriminant: an integer (or integer like object)
** should return (cube, info)
*** cube: the initial cube constructed so (A1,B1,C1) = (A2,B2,C2) = (2, 1, (1-disc)//8)
*** info: any object you wish which will be passed onto 'run' for convenience. Its intended purpose is to hold values that only need to be calculated once at startup, or pass possibly useful internal values from a run calculation to the next step.

The default setup creates the initial cube for you, and info is just an empty dictionary object that 'run' can shove internal values into if it wants.

A algorithm entry must define:

* a function `run(cube, info)`
** parameter cube: will be a tuple of 8 integers (or integer like objects)
** parameter info: the info object created by the setup routine
** returns new_cube: a new tuple of 8 integer values which meet the algebraic constraints of the algorithm which were described earlier


It is strongly recommended to take a look at `example.py` and `example2.py`.

As a quick test, try running: `./run_test.py example`


= Useful algebra results

Starting with the original 9 cube equations, for some purposes it is
convenient to expand them into the following 12 equations.
....
  bc - ad = A1
  ce - ag = A2
  be - af = A3
  cf - ah = (B1 + B2)/2
  bg - de = (B1 - B2)/2
  bg - ah = (B1 + B3)/2
  cf - de = (B1 - B3)/2
  de - ah = (B2 + B3)/2
  cf - bg = (B2 - B3)/2
  fg - eh = C1
  df - bh = C2
  dg - ch = C3
....

These can then be manipulated to form more linear looking relationships that
must hold for any cube solution.
....
  a C3 + g A1 = c (B1 + B3)/2
  a C1 + g A3 = e (B1 + B3)/2
  b C3 + h A1 = d (B1 + B3)/2
  b C1 + h A3 = f (B1 + B3)/2

  e A1 - c A3 = a (B1 - B3)/2
  f A1 - d A3 = b (B1 - B3)/2
  c C1 - e C3 = g (B1 - B3)/2
  d C1 - f C3 = h (B1 - B3)/2

  e A1 - b A2 = a (B1 - B2)/2
  g A1 - d A2 = c (B1 - B2)/2
  b C1 - e C2 = f (B1 - B2)/2
  d C1 - g C2 = h (B1 - B2)/2

  a C2 + f A1 = b (B1 + B2)/2
  c C2 + h A1 = d (B1 + B2)/2
  a C1 + f A2 = e (B1 + B2)/2
  c C1 + h A2 = g (B1 + B2)/2

  b A2 - c A3 = a (B2 - B3)/2
  f A2 - g A3 = e (B2 - B3)/2
  c C2 - b C3 = d (B2 - B3)/2
  g C2 - f C3 = h (B2 - B3)/2

  d A3 + a C2 = b (B3 + B2)/2
  a C3 + d A2 = c (B3 + B2)/2
  h A3 + e C2 = f (B3 + B2)/2
  e C3 + h A2 = g (B3 + B2)/2
....

If given all the tuple values, this is now a system of linear equations for the
cube values. Of the 24 linear equations, only 6 are linearly independent, so
the 8 cube values can be solved with 2 freedoms remaining.

These freedoms are just from the linear equations not specifying all of the
original constraints. For example it is clear setting all the cube values to
zero would satisfy the linear equations, but not the original equations.

So choosing some non-zero tuple value, the original quadratic equation
can be used to constrain the final 2 freedoms (this constraint looks like
a quadratic form equal to a constant). Therefore this gives a unique solution
up to an overall sign.


= Skim some deeper math details

== Composition

It can be proven that if given (A2,B2,C2) and (A3,B3,C3) such that

* the values are relatively prime `gcd(A2,B2,C2) = gcd(A3,B3,C3) = 1`
* and `B2^2 - 4 A2 C2 = B3^2 - 4 A3 C3`

then necessarily

* there exists a solution to the cube equations
* the solution is not unique, but are related in a simple way that will be explored shortly.

This can be use to define the following property: (A1,-B1,C1) is said to be a
"composition" of the tuples (A2,B2,C2), (A3,B3,C3) if such a cube exists.

Due to symmetry of the cube and the equations, this can also be said for the
other tuples. Given a solution, we can also say (A2,-B2,C2) is a "composition"
of the tuples (A1,B1,C1), (A3,B3,C3).  And (A3,-B3,C3) is a "composition" of
the tuples (A1,B1,C1), (A2,B2,C2).

By expanding the tuple values in terms of the cube values, it can be checked
that for any solution:
....
  B1^2 - 4 A1 C1 = B2^2 - 4 A2 C2 = B3^2 - 4 A3 C3
....
This value is called the discriminant. As mentioned above, this value is
important for the existence of solutions given just two tuples. So in what
follows, let's restrict consideration of tuples to those of some given
discriminant. For convenience, and to match additional assumptions that are
given for the inputs to our math puzzle, the discriminant will be taken to be -p where
p is a prime number.

With this restriction going forward, for any two tuples under consideration
there will always exist a third which is a composition of those two tuples.

== Equivalence

Define two tuples (A,B,C) and (A',B',C') to be "equivalent" if there exists two
other tuples T1 and T2 such that (A,B,C) is a composition of T1
and T2, and (A',B',C') is also a composition of T1 and T2. We will
denote that two tuples are equivalent by writing tuple1 ~ tuple2.


== Composition respects equivalence

The composition property respects the equivalence relation in the following
way. If T1 ~ T2 and T3 ~ T4, then any tuple which is a
composition of T1 and T3 is equivalent to any tuple which is a
composition of T2 and T4.

We can rewrite this more cleanly if we define "*" between tuples to mean
composition, so that (tuple1 * tuple2) as an operation results in some tuple
such that it is the composition of tuple1 and tuple2. The previous result can
then be written:
....
    if  T1 ~ T2  and  T3 ~ T4,  then  (T1 * T3) ~ (T2 * T4)
....

== Further properties of composition

It turns out that this operation has nice properties.

* commutative: `(T1 * T2) ~ (T2 * T1)`
* associative: `(T1 * (T2 * T3)) ~ ((T1 * T2) * T3)`

Reminding that we are restricting to considering the set of tuples with a
particular discriminant, we can further say

* closed: for any two tuple T1,T2 in this set, there exists a T3 which is a composition of T1 * T2.
* identity: there exists a tuple T_identity in this set such that for all
forms T2, (T_identity * T2) ~ T2.
* inverse: for every tuple T1 in this set, there exists a tuple T2 such that
(T1 * T2) ~ T_identity.


== composition of cubes

Now consider two cubes given by the tuples T1a,T1b,T1c and T2a,T2b,T2c
respectively. Then we have:

....
cube1: T1a ~ T1b * T1c
cube2: T2a ~ T2b * T2c

There exist tuples given by the relations
 T3a ~ T1a * T2a
 T3b ~ T1b * T2b
 T3c ~ T1c * T2c

Which from above therefore have the relationship
 T3a ~ T3b * T3c
....

and so composition of tuples, along with existence of a cube for any
three tuples that satisfy a composition relation, means that given two
cubes a third exists which is a "composition" of two other cubes.

It is this cube composition which the algorithm contest involves.


== Function to create, viewed as composition of cubes

In the competition, your function will be given (a,b,c,d,e,f,g,h)
specifying a cube, with the guarantee that the first two tuples are equal
(A1,B1,C1) = (A2,B2,C2).

Using cube composition, a new cube must be calculated such that

* the new cube is the old cube composed with itself
* the new cube also has the first two tuples equal (A1',B1',C1')=(A2',B2',C2')

Note:
....
(A3,B3,C3) ~ (A1,B1,C1) * (A2,B2,C2) ~ (A1,B1,C1) * (A1,B1,C1) ~ (A1',B1',C1')
....


= Properties of solutions to the cube equations

The cube equations have some interesting properties.

== New solution with overall sign flip

Since all the tuple values A1,A2,etc. are degree 2 polynomials in terms of the
cube values, if we invert all the cube values, this does not change the tuple
values.

== Preserving Tuple1,Tuple2 and changing Tuple3

Given a cube, there are some simple transformations we can do to the values
which preserves two of the three tuples, and changes the third in a simple way.

....
swap the values according to
    (a',b',c',d', e',f',g',h') = (c,d,-a,-b, g,h,-e,-f)

A1' = b' c' - a' d' = d (-a) - c (-b) = bc - ad = A1
A2' = c' e' - a' g' = (-a) g - c (-e) = ce - ag = A2
A3' = b' e' - a' f' = d g - c h = C3
and so on...

it is found that
    A1',B1',C1' = A1,B1,C1
    A2',B2',C2' = A2,B2,C2
    A3',B3',C3' = C3,-B3,A3
....

another operation preserving Tuple1,Tuple2 and changing Tuple3 is

....
given any integer n
    (a',b',c',d', e',f',g',h') = (a,b,c+an,d+bn, e,f,g+en,h+fn)

C1' = f' g' - e' h' = f (g+en) - e (h+fn) = fg - eh = C1
C2' = d' f' - b' h' = (d+bn) f - b (h+fn) = df - bh = C2
C3' = d' g' - c' h' = (d+bn)(g+en) - (c+an)(h+fn)
                    = (dg-ch) + n(-ah + bg - cf + de) + n^2(be - af)
                    = C3 + n B3 + n^2 A3
and so on...

it is found that
    A1',B1',C1' = A1,B1,C1
    A2',B2',C2' = A2,B2,C2
    A3',B3',C3' = A3, B3 + 2n A3, C3 + n B3 + n^2 A3
....

The previous two manipulations can be rephrased nicely in the language
of linear algebra

....
first
    |a' b' e' f'| = | 0 1| |a b e f|
    |c' d' g' h'|   |-1 0| |c d g h|

    | A3'  B3'/2| = | 0 1| | A3  B3/2| |0 -1|
    |B3'/2  C3' |   |-1 0| |B3/2  C3 | |1  0|


second
    |a' b' e' f'| = |1 0| |a b e f|
    |c' d' g' h'|   |n 1| |c d g h|

    | A3'  B3'/2| = |1 0| | A3  B3/2| |1 n|
    |B3'/2  C3' |   |n 1| |B3/2  C3 | |0 1|
....

These two manipulations can combined, and repeated.

....
general case
modify with any matrix such that ru - st = 1
    |a' b' e' f'| = |r s| |a b e f|
    |c' d' g' h'|   |t u| |c d g h|

    | A3'  B3'/2| = |r s| | A3  B3/2| |r t|
    |B3'/2  C3' |   |t u| |B3/2  C3 | |s u|
....

This freedom in the tuple is precisely the freedom in the
equivalance relation mentioned above.

== Preserving Tuple1,Tuple3 or Tuple2,Tuple3

By symmetry of the cube and equations, similar manipulations can be
done which only change Tuple2 or only change Tuple1.


= Why another contest?

"High level overview of hope for algorithm improvments" would be another way
of framing this section.

All current best methods of calculating a form composition require calculating
one extended gcd. The result however has large numbers, and so to prevent the
size of the numbers exploding with repeated application, a form "reduction"
is performed (finding in a sense the smallest form equivalent to the
form just calculated). This reduction is in many ways similar to the euclidean
algorithm. This is where most of the computation time goes, in these two
"gcd" like calculations: one for getting the composition, the other for
reducing.

Naively, composing two cubes solves three form compositions. However, a cube
with holds the result of two of the compositions, necessarily then already
holds a solution to the third. So for composing two arbitrary cubes, the
expected cost should be at least two xgcd, and hopefully only one reduction
like operation on the cube.

However, we are interested in a very special case:

* we are trying to compose a cube with itself
* that cube has `form1 = form2`, and so `form3 ~ form1^2 = form2^2`

Therefore in the resulting cube, we already know the answer to two of the
form compositions. If we can fit that into the cube, we get the third for free.
In this ultra idealistic case, repeated squaring may not even require an xgcd.

On the other end of the spectrum from idealistic hopes, we know, because the
algorithm exists (and are included in the contest library), that we can
construct a cube from scratch with form1 = form2 = anything with a single xgcd.

So inbetween, in the conservative but hopeful case, is that there is some
algebraic solution to the cube composition, such that our special conditions
help, and we do not need to completely toss the cube and start from scratch
each time. Therefore, still requiring an xgcd, but in values roughly
square-root the typical values of A1,B1,C1. And then a reduction operation on
the cube, again operating on mostly already reduced size values.

That hope feels plausible to me. And this feels especially plausible when you
realize the current best algorithm for squaring in form composition, called
NUDUPL, can be rephrased as constructing a cube, and the main savings is from
doing most of the reduction operation in cube form, before calculating the
resulting forms (which then use some other algorithm to reduce the rest of the
way).

In short, the bet is there are further improvements to be made if we just
"stay in the cube representation". It feels there should be a better way than
each time constructing the cube from scratch, using it for some speed up, then
tossing the cube away, only to require constructing another one from scratch
in the next step and so on.

THIS is the kind of general algorithmic improvement that would lead to
speed-ups regardless of the hardware architecture, even in design of ASIC
devices.

And this is why this contest exists, despite two previous contests already
involved with squaring in form composition. The previous competitions
instead focussed on raw wall clock time on hyper-specific hardware
architectures with no standardization of the math library, and thus the result
followed the incentives: everyone used the same decades old NUDUPL
algorithm, made form reduction use standard gcd type speedups, which left the
main focus in improvements largely in assembly language details very specific
to the selected achitectures. Maybe that wasn't the initial intention, but
the second contest clearly doubled down on this for some reason.

This contest possibly swings too far to the other side. Its setup strongly
suggests a particular path for improvement. However, the included library
could be used to form other community led competitions that allows focus
primarily on algorithm improvements instead of architecture specific math
libarary improvements.


= Reference

* solving linear integer equations, ax + by = c
** wikipedia: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm[Extended Euclidean algorithm]
** wikipedia: https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity[Bezout's identity]
** textbook style discussion of solutions, http://gauss.math.luc.edu/greicius/Math201/Fall2012/Lectures/linear-diophantine.article.pdf[pdf]
* binary quadratic forms
** wikipedia: https://en.wikipedia.org/wiki/Binary_quadratic_form[binary quadratic forms]
** introduction by Lipa Long from Chia Network, https://github.com/Chia-Network/vdf-competition/blob/master/classgroups.pdf[classgroups.pdf]
* Bhargava cubes
** wikipedia: https://en.wikipedia.org/wiki/Bhargava_cube[Bhargava cubes]
** original article (math jargon heavy) by Bhargava, _"Higher composition laws I: A new view on Gauss composition, and quadratic generalizations"_, https://annals.math.princeton.edu/wp-content/uploads/annals-v159-n1-p03.pdf[pdf]


= Acknowledgements

inkfish from https://github.com/Chia-Network/vdf-competition.git

